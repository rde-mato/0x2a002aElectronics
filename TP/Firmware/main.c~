#include <xc.h>
#include "tp.h"
#include <sys/attribs.h>

/*
 * LOGIQUE GENERALE
 * 32 LEDs a allumer tiennent sur un u32
 * on cree donc un buffer qui tient dans un u32
 *
 * une variable globale tempo donne le rythme et genere un interrupt regulierement
 * a chacun de ces interrupts, le buffer des LEDs est lu et affiche
 * l'affichage declenche lui meme un interrupt qui va remplir a nouveau le buffer
 * question : doit-on signaler que le buffer est pret pour l'envoyer ? systeme de blocage ?
 *
 * le buffer est rempli en OUant les

 */

// A REVOIR APRES EN FONCTION DU FLOW QU"ON DECIDE
//u32 buf = 0xF0F0;
//u32 to_send = (buf & (1UL << 0) << 3)
//                | (buf & (1UL << 1) << 10)
//                | (buf & (1UL << 2) << 7)
//                | (buf & (1UL << 3) << 9)
//                | (buf & (1UL << 4) >> 4)
//                | (buf & (1UL << 5) >> 4)
//                | (buf & (1UL << 6) << 5)
//                | (buf & (1UL << 7) << 5)
//                | (buf & (1UL << 8) << 6)
//                | (buf & (1UL << 9) >> 6)
//                | (buf & (1UL << 10) >> 1)
//                | (buf & (1UL << 11) >> 3)
//                | (buf & (1UL << 12) >> 6)
//                | (buf & (1UL << 13) >> 8)
//                | (buf & (1UL << 14) >> 10)
//                | (buf & (1UL << 15) >> 5);

u8 twice_hz = 1;
char pattern[16][4][3];
char qtime = 0;
static u16   displaybuff[4];
static u8   buttonbuff[16];
int incr = -1;

static u16  ledmatrix[16] = {
    0x0004, 0x8000, 0x2000, 0x1000,
    0x0001, 0x0002, 0x0800, 0x1000, /// DUPLICAT ?!
    0x4000, 0x0008, 0x0200, 0x0100,
    0x0040, 0x0020, 0x0010, 0x0400,
};
//ks1 4: 0x0400 11: 0x0001 12: 0x0200 16: 0x0002

//ks0 1: 0x8000 2: 0x1000 3: 0x0400 5: 0x2000 6: 0x4000 7: 0x0100 8: 0x0200 9: 0x0800 10: 0x0001 13: 0x0008 14: 0x0004 15: 0x0002


static const u32 buttonmatrix[16] = {
    0x80000000,
    0x10000000,
    0x04000000,
    0x00000400,
    0x20000000,
    0x40000000,
    0x01000000,
    0x02000000,
    0x08000000,
    0x00010000,
    0x00000001,
    0x00000200,
    0x00080000,
    0x00040000,
    0x00020000,
    0x00000002
};

void scan_input(void)
{
    u32 ks;
    
    I2C2_start();
    I2C2_write(0xE0);
    I2C2_write(0x40);
    I2C2_stop();

    I2C2_start();
    I2C2_write(0xE1);
    ks = I2C2_read(1) << 24; // 1 : send a ack: continues
    ks |= I2C2_read(1) << 16;
    ks |= I2C2_read(1) << 8;
    ks |= I2C2_read(0);
    I2C2_stop();

    u8 i;
    for (i = 0; i < 16; i++)
    {
        if (buttonmatrix[i] & ks)
            buttonbuff[i] = 1;
        else
            buttonbuff[i] = 0;
    }
}




void led_set(u8 index)
{
    displaybuff[3 - index / 4] |= ledmatrix[index];
}

void led_toggle(u8 index)
{
    displaybuff[3 - index / 4] ^= ledmatrix[index];
}


void led_clr(u8 index)
{
    displaybuff[3 - index / 4] &= ~ledmatrix[index];
}

void led_refresh(void)
{
    I2C2_start();
    I2C2_write(0xE0);
    I2C2_write(0x00);
    int i;
    for (i = 0; i < 4; i++)
    {
        I2C2_write(displaybuff[i] >> 8);
        I2C2_write(displaybuff[i] & 0xFF);
    }
    I2C2_stop();
}

void send_qtime(void)
{
    u8 note = 0;
    
    while (pattern[qtime][note][notevalue])
    {
        UART2_send(pattern[qtime][note][notestatus]);
        UART2_send(pattern[qtime][note][notevalue]);
        UART2_send(pattern[qtime][note][notevelo]);
        note = (note + 1) % 4;
    }
}


void __ISR(_TIMER_3_VECTOR, IPL3AUTO) Timer3Handler(void)
{
    //send_msg();
    //LED_ON_OFF = !LED_ON_OFF;

    //truc de led de ouf

 //   led_toggle(4);
    qtime = (qtime + 1) % 16;
    //led_refresh();
    if (qtime == 16 || qtime == 0)
    {
        incr = -incr;
    }
    if (incr > 0)
        led_set(qtime);
    else
        led_clr(qtime);
    
    TMR2 = 0;
    IFS0bits.T3IF = 0;
}

int main(void)
{
    init_pattern();
    GPIO_init();
    TIMER_init();
    INT_init();
    T2CONbits.ON = 1;

    I2C2_init();
    HT16_init();

    while (42)
        WDTCONbits.WDTCLR = 1; // CLEAR WATCHDOG
    return (0);
}
